<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Worker 测试</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 2rem;
      max-width: 1200px;
      margin: 0 auto;
    }
    .test-section {
      margin-bottom: 2rem;
      padding: 1rem;
      border: 1px solid #ddd;
      border-radius: 4px;
    }
    button {
      padding: 0.5rem 1rem;
      margin: 0.5rem;
      cursor: pointer;
    }
    .log {
      background: #f5f5f5;
      padding: 1rem;
      border-radius: 4px;
      max-height: 400px;
      overflow-y: auto;
      font-family: monospace;
      font-size: 0.875rem;
    }
    .log-item {
      margin-bottom: 0.5rem;
      padding: 0.25rem;
    }
    .log-item.error {
      color: red;
    }
    .log-item.success {
      color: green;
    }
  </style>
</head>
<body>
  <h1>Worker 功能测试</h1>

  <div class="test-section">
    <h2>测试 1: 创建测试文件</h2>
    <button onclick="createTestFile()">创建 10MB 测试文件</button>
    <button onclick="createSmallFile()">创建 100KB 测试文件</button>
    <div id="file-info"></div>
  </div>

  <div class="test-section">
    <h2>测试 2: Worker URL 解析</h2>
    <button onclick="testWorkerUrl()">测试 Worker URL</button>
    <div id="url-info"></div>
  </div>

  <div class="test-section">
    <h2>测试 3: Worker 创建和消息传递</h2>
    <button onclick="testWorkerCreation()">测试 Worker 创建</button>
    <button onclick="testWorkerMessage()">测试 Worker 消息传递</button>
    <div id="worker-info"></div>
  </div>

  <div class="test-section">
    <h2>测试 4: 完整分片流程</h2>
    <button onclick="testFragmentFile()">测试文件分片</button>
    <div id="fragment-info"></div>
  </div>

  <div class="test-section">
    <h2>日志</h2>
    <button onclick="clearLog()">清空日志</button>
    <div id="log" class="log"></div>
  </div>

  <script type="module">
    import { 
      fragmentFile, 
      getWorkerUrl, 
      createWorker,
      calculateChunkStrategy 
    } from './src/index.ts'

    window.fragmentFile = fragmentFile
    window.getWorkerUrl = getWorkerUrl
    window.createWorker = createWorker
    window.calculateChunkStrategy = calculateChunkStrategy

    // 日志函数
    function log(message, type = 'info') {
      const logDiv = document.getElementById('log')
      const item = document.createElement('div')
      item.className = `log-item ${type}`
      item.textContent = `[${new Date().toLocaleTimeString()}] ${message}`
      logDiv.appendChild(item)
      logDiv.scrollTop = logDiv.scrollHeight
      console.log(message)
    }

    window.log = log

    // 创建测试文件
    window.createTestFile = function() {
      try {
        const size = 10 * 1024 * 1024 // 10MB
        const content = new Uint8Array(size)
        for (let i = 0; i < size; i++) {
          content[i] = i % 256
        }
        const blob = new Blob([content], { type: 'application/octet-stream' })
        const file = new File([blob], 'test-10mb.bin', {
          type: 'application/octet-stream',
          lastModified: Date.now(),
        })
        window.testFile = file
        document.getElementById('file-info').innerHTML = `
          <p>✅ 文件创建成功</p>
          <p>文件名: ${file.name}</p>
          <p>大小: ${(file.size / 1024 / 1024).toFixed(2)} MB</p>
          <p>类型: ${file.type}</p>
        `
        log(`创建测试文件成功: ${file.name}, 大小: ${(file.size / 1024 / 1024).toFixed(2)} MB`, 'success')
      } catch (error) {
        log(`创建文件失败: ${error.message}`, 'error')
      }
    }

    window.createSmallFile = function() {
      try {
        const size = 100 * 1024 // 100KB
        const content = new Uint8Array(size)
        for (let i = 0; i < size; i++) {
          content[i] = i % 256
        }
        const blob = new Blob([content], { type: 'application/octet-stream' })
        const file = new File([blob], 'test-100kb.bin', {
          type: 'application/octet-stream',
          lastModified: Date.now(),
        })
        window.testFile = file
        document.getElementById('file-info').innerHTML = `
          <p>✅ 文件创建成功</p>
          <p>文件名: ${file.name}</p>
          <p>大小: ${(file.size / 1024).toFixed(2)} KB</p>
          <p>类型: ${file.type}</p>
        `
        log(`创建小文件成功: ${file.name}, 大小: ${(file.size / 1024).toFixed(2)} KB`, 'success')
      } catch (error) {
        log(`创建文件失败: ${error.message}`, 'error')
      }
    }

    // 测试 Worker URL
    window.testWorkerUrl = function() {
      try {
        const url = getWorkerUrl('work.js')
        document.getElementById('url-info').innerHTML = `
          <p>✅ Worker URL: ${url.href}</p>
          <p>路径: ${url.pathname}</p>
        `
        log(`Worker URL: ${url.href}`, 'success')
      } catch (error) {
        log(`获取 Worker URL 失败: ${error.message}`, 'error')
      }
    }

    // 测试 Worker 创建
    window.testWorkerCreation = async function() {
      try {
        log('开始创建 Worker...')
        const worker = createWorker('work.js')
        
        worker.onmessage = (e) => {
          log(`Worker 消息: ${JSON.stringify(e.data)}`, 'success')
          worker.terminate()
        }

        worker.onerror = (error) => {
          log(`Worker 错误: ${error.message || '未知错误'}`, 'error')
          document.getElementById('worker-info').innerHTML = `
            <p class="error">❌ Worker 错误</p>
            <p>消息: ${error.message || '未知错误'}</p>
            <p>文件名: ${error.filename || '未知'}</p>
            <p>行号: ${error.lineno || '未知'}</p>
          `
        }

        // 等待一下确保 Worker 加载
        await new Promise(resolve => setTimeout(resolve, 1000))
        
        document.getElementById('worker-info').innerHTML = `
          <p>✅ Worker 创建成功</p>
          <p>尝试发送测试消息...</p>
        `
        
        // 发送测试消息
        worker.postMessage({ test: 'hello' })
        
        log('Worker 创建成功，已发送测试消息', 'success')
      } catch (error) {
        log(`创建 Worker 失败: ${error.message}`, 'error')
        document.getElementById('worker-info').innerHTML = `
          <p class="error">❌ 创建 Worker 失败</p>
          <p>错误: ${error.message}</p>
        `
      }
    }

    // 测试 Worker 消息传递（使用 File）
    window.testWorkerMessage = async function() {
      if (!window.testFile) {
        alert('请先创建测试文件')
        return
      }

      try {
        log('开始测试 Worker 消息传递（File 对象）...')
        const worker = createWorker('work.js')
        
        let messageReceived = false

        worker.onmessage = (e) => {
          messageReceived = true
          log(`Worker 返回消息: ${JSON.stringify(e.data)}`, 'success')
          worker.terminate()
        }

        worker.onerror = (error) => {
          log(`Worker 错误: ${error.message || '未知错误'}`, 'error')
          document.getElementById('worker-info').innerHTML = `
            <p class="error">❌ Worker 消息错误</p>
            <p>消息: ${error.message || '未知错误'}</p>
            <p>文件名: ${error.filename || '未知'}</p>
            <p>行号: ${error.lineno || '未知'}</p>
            <p>错误对象: ${JSON.stringify(error.error || {})}</p>
          `
          worker.terminate()
        }

        // 等待 Worker 加载
        await new Promise(resolve => setTimeout(resolve, 1000))

        log(`尝试发送 File 对象到 Worker: ${window.testFile.name}, 大小: ${window.testFile.size}`)
        
        try {
          worker.postMessage({
            file: window.testFile,
            CHUNK_SIZE: 1024 * 1024, // 1MB
            startIndex: 0,
            endIndex: 1,
          })
          log('File 对象发送成功', 'success')
          
          // 等待响应
          setTimeout(() => {
            if (!messageReceived) {
              log('⚠️ 未收到 Worker 响应（可能 Worker 仍在处理）', 'error')
            }
          }, 5000)
        } catch (postError) {
          log(`发送消息失败: ${postError.message}`, 'error')
          document.getElementById('worker-info').innerHTML = `
            <p class="error">❌ 发送消息失败</p>
            <p>错误: ${postError.message}</p>
            <p>堆栈: ${postError.stack}</p>
          `
          worker.terminate()
        }
      } catch (error) {
        log(`测试失败: ${error.message}`, 'error')
        document.getElementById('worker-info').innerHTML = `
          <p class="error">❌ 测试失败</p>
          <p>错误: ${error.message}</p>
        `
      }
    }

    // 测试完整分片流程
    window.testFragmentFile = async function() {
      if (!window.testFile) {
        alert('请先创建测试文件')
        return
      }

      try {
        log(`开始测试文件分片: ${window.testFile.name}`)
        document.getElementById('fragment-info').innerHTML = '<p>处理中...</p>'

        const startTime = Date.now()
        
        const chunks = await fragmentFile(
          window.testFile,
          1024 * 1024, // 1MB chunks
          (error) => {
            log(`错误: ${error.message}`, 'error')
          },
          (progress) => {
            log(`进度: ${progress.percentage}% (${progress.processedChunks}/${progress.totalChunks} 分片)`)
            document.getElementById('fragment-info').innerHTML = `
              <p>进度: ${progress.percentage}%</p>
              <p>已处理: ${progress.processedChunks}/${progress.totalChunks} 分片</p>
            `
          }
        )

        const endTime = Date.now()
        const duration = ((endTime - startTime) / 1000).toFixed(2)

        document.getElementById('fragment-info').innerHTML = `
          <p>✅ 分片完成</p>
          <p>总分片数: ${chunks.length}</p>
          <p>处理时间: ${duration} 秒</p>
          <p>第一个分片哈希: ${chunks[0]?.hash.substring(0, 16)}...</p>
        `
        log(`分片完成: ${chunks.length} 个分片，耗时 ${duration} 秒`, 'success')
      } catch (error) {
        log(`分片失败: ${error.message}`, 'error')
        document.getElementById('fragment-info').innerHTML = `
          <p class="error">❌ 分片失败</p>
          <p>错误: ${error.message}</p>
          <p>堆栈: ${error.stack}</p>
        `
      }
    }

    window.clearLog = function() {
      document.getElementById('log').innerHTML = ''
    }

    log('测试页面已加载')
  </script>
</body>
</html>
